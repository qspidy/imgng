# Rate limiting for upload endpoint (must be in http block)
limit_req_zone $binary_remote_addr zone=upload_limit:10m rate=10r/m;

# HTTPS server
server {
    listen 443 ssl http2;
    server_name example.com;

    # SSL parameters
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_certificate /etc/ssl/__DOMAIN__.pem;
    ssl_certificate_key /etc/ssl/__DOMAIN__.key;

    # Log files
    access_log /var/log/nginx/img-host.access.log;
    error_log /var/log/nginx/img-host.error.log;

    gzip on;

    # ACME challenge for SSL renewal
    location /.well-known/acme-challenge {
        alias /var/www/html/.well-known/acme-challenge;
        try_files $uri =404;
    }

    # Images subdirectory (configure via IMAGE_PATH env var)
    location __IMAGE_PATH__ {
        alias __STORAGE_PATH__;
        # Hotlink protection
        valid_referers none blocked *.example.com;
        if ($invalid_referer) {
            return 403;
        }
        expires 30d;
        add_header Cache-Control "public";
    }

    # Upload endpoint (configure via UPLOAD_PATH env var)
    location __UPLOAD_PATH__ {
        limit_except POST { deny all; }

        # Rate limiting (10 req/min per IP, burst of 5)
        limit_req zone=upload_limit burst=5 nodelay;

        # Authentication
        auth_basic "Upload";
        auth_basic_user_file /etc/nginx/.htpasswd;

        client_max_body_size 20M;
        client_body_in_file_only on;
        client_body_temp_path /tmp/nginx_upload;

        content_by_lua_block {
            -- Force nginx to read request body
            ngx.req.read_body()

            local file = ngx.req.get_body_file()
            if not file then
                ngx.status = 400
                ngx.say("no body file")
                return
            end

            -- Get file extension from header, or detect from file type
            local ext = ngx.var.http_x_file_extension or ""

            if ext == "" then
                -- Detect file type using file command
                local handle = io.popen("/usr/bin/file -b --mime-type " .. file .. " 2>/dev/null")
                local mime_type = handle:read("*a")
                handle:close()

                -- Map MIME types to extensions
                local mime_to_ext = {
                    ["image/jpeg"] = "jpg",
                    ["image/png"] = "png",
                    ["image/webp"] = "webp",
                    ["image/gif"] = "gif",
                    ["image/avif"] = "avif",
                }

                ext = mime_to_ext[mime_type:gsub("%s+", "")] or "bin"
            else
                ext = ext:gsub("^%.", "")
            end

            local id = ngx.var.request_id
            local target = "__STORAGE_PATH__" .. id .. "." .. ext

            -- Move file to final location
            local ok, err = os.rename(file, target)
            if not ok then
                ngx.status = 500
                ngx.say("rename failed: ", err)
                return
            end

            -- Optimize images (requires ImageMagick)
            local image_extensions = {jpg=true, jpeg=true, png=true, webp=true, gif=true, avif=true}
            if image_extensions[ext:lower()] then
                local optimize_cmd = "/usr/bin/mogrify -quality 85 -strip " .. target
                os.execute(optimize_cmd .. " 2>/dev/null")
                -- Restore 600 permissions after ImageMagick
                os.execute("/bin/chmod 600 " .. target .. " 2>/dev/null")
            end

            -- Return full URL with image path prefix
            local image_path = "__IMAGE_PATH__"
            local url = ngx.var.scheme .. "://" .. ngx.var.host .. image_path .. id .. "." .. ext
            ngx.header["X-File"] = id .. "." .. ext
            ngx.say(url)
        }
    }
}

# HTTP to HTTPS redirect
server {
    listen 80;
    server_name example.com;
    return 301 https://$host$request_uri;
}
